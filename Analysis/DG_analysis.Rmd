---
title: "DG-ToG-Donation Analysis"
author: "Pagano S. & Guido A."
date: "23/02/2022"
output: html_document
---

```{r library and master file, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
rm(list=ls())
library(ggplot2)
library(tidyverse)
library(mlogit)
library(sjmisc)
library(ggrepel)
library(readxl)
library(sjPlot)
library(ggpubr)
library(foreign)
library(survival)
library(gridExtra)
library(kableExtra)
library(car)
library(DT)
library(zoo)
library(AICcmodavg)
library(boot)
library(arm)

setwd("../")

# read data beliefs and choices with ALL DATA
master <- read.csv("File_DB/Output/Treatment.csv") %>%
  mutate(treatment_id=paste(PaperID,TreatmentCode,sep="_"))
beliefs <- read.csv("File_DB/Output/Subjects_beliefs.csv", sep = ",")
choices <- read.csv("File_DB/Output/Subjects_choices.csv", sep = ",")

setwd("Paper_csv/")
df_avg_kw <- read.csv("2016Kim003_avg_kw.csv", sep = ",") 
df_avg_kw <- read.csv("2018Her061_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw)
df_avg_kw <- read.csv("2013Kru001_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw)
df_avg_kw <- read.csv("2019Cha026_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw)
df_avg_kw <- read.csv("2012Laz164_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw)
df_avg_kw <- read.csv("2007Lis165_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw)
df_avg_kw <- read.csv("2020Bas115_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw) 
df_avg_kw <- read.csv("2020And089_avg_kw.csv", sep = ",") %>% rbind.data.frame(df_avg_kw) %>%
  mutate(treatment_id = paste(PaperID,"_",TreatmentCode,sep=""))
```


# Search criteria {.tabset .tabset-pills}

The selection criteria to identify papers in target was:

-   **Game type** (cooperation and prosociality games):

    -   Dictator Game
    -   Take or Give Game
    -   Donation Game

-   Presence of norm elicitation task:

    -   Krupka and Weber (2013);

-   Only monetary incentivized studies (both choices and norms
    elicitation).

-   Baseline treatment (no framing)

-   Standard game

    -   Not a minigame
    -   Two players
    -   No papers that give the recipient any kind of power (and thereby
        bring the experiment close to an ultimatum game);
    -   No papers that mix the motive of benevolence with one of
        sanctioning the recipient
    -   No papers that limit the dictator's action space such that it
        does not include the option to give nothing nor to take from the
        recipient
    -   No real effort task used to determine the dictator's endowment

-   Both choice and normative task

-   Data available

## Dictator Game {.tabset .tabset-pills}

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
# subset of dg data
master_dg <- master %>% 
  filter(Game_type == "DG") %>%
  subset.data.frame(subset = !(Standard_game %in% c("N")) & 
                      Choice_Method != "OnlyNorms" & 
                      StatusTreatment_Roma == "6-Complete" & 
                      Baseline %in% c(NA, 1)) %>% 
  mutate(treatment_id = paste(PaperID,"_",TreatmentCode,sep=""))

# list of treatments in target
list_of_paper_in_target <- master_dg %>% 
                    dplyr::select(PaperID, TreatmentCode, TreatmentName_paper, 
                               Year, Game_type, Standard_game, 
                               Baseline, Group_size, Rounds, 
                               Method_elicitation, Avg_coop, Avg_NE, 
                               Var_coop, Var_NE, Avg_KW_m)

# read file beliefs and choices
beliefs_dg <- beliefs %>%
  filter(treatment_id %in% levels(as.factor(paste(master_dg$PaperID,"_",master_dg$TreatmentCode, sep=""))))

choices_dg <- choices  %>%
  filter(treatment_id %in% levels(as.factor(paste(master_dg$PaperID,"_",master_dg$TreatmentCode, sep=""))))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# print table of "list_of_paper_in_target"
opts <- options(knitr.kable.NA = "")
kbl(list_of_paper_in_target,
    digits = 4, 
    booktabs = T, 
    align = "llllllllllrrrrrr", 
    centering = F, 
    caption="List of paper after selection criteria applied") %>%
  kable_styling(position = "left", 
                full_width = F) %>%
  column_spec(1, bold = T)
```

### Descriptive Plots {.tabset .tabset-pills}

<!-- tab: beliefs, choices -->

#### Beliefs

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}

DG_avg_kw <- df_avg_kw %>% merge.data.frame(master_dg %>% 
                                               subset.data.frame(dplyr::select = c(PaperID, 
                                                                            TreatmentName_paper, 
                                                                            TreatmentCode, 
                                                                            treatment_id)), 
                                             by = c("PaperID","TreatmentCode","treatment_id")) %>% 
  filter(!(is.na(TreatmentName_paper)))
temp_master <- DG_avg_kw %>% 
  distinct(treatment_id)

# inizializing variable for loop
n=1
list_plot <- c()

# creation of a plots list
for (i in temp_master$treatment_id) {
  
  # dataset
  temp_master_for <- DG_avg_kw %>% 
    filter(treatment_id == i)
  
  # list
  list_plot[[n]] <- ggplot(temp_master_for, 
                           aes(x=donation, y=Kw_m)) + 
    geom_bar(stat = "identity") + 
    labs(title = i, 
         subtitle = temp_master_for$TreatmentName_paper[temp_master_for$treatment_id == i]) +
    ylim(-1,1) +
    xlab("Scenario") + 
    ylab("Appropriateness (average)")
  
  n=n+1
}

# merge plots in one figure
do.call('grid.arrange', 
        c(list_plot, ncol = 2))
```

#### Choices

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
# dataset
perc_choices <- choices_dg %>% 
  filter(A==1) %>% 
  group_by(treatment_id, choice) %>% 
  summarise(n_of_sub = n(),
            endowment = mean(endowment)) %>%
  merge.data.frame(master_dg %>% 
                     subset.data.frame(dplyr::select = c(PaperID, TreatmentName_paper, 
                                                  TreatmentCode, treatment_id)), 
                   by = "treatment_id") %>% 
  filter(!(is.na(TreatmentName_paper)))

temp_master <- choices_dg %>% 
  distinct(treatment_id)

# inizializing variables for loop
n=1
list_plot <- c()

# creation of a plots list
for (i in temp_master$treatment_id) {
  
  # dataset
  temp_master_for <- perc_choices %>% 
    filter(treatment_id == i)
  temp_master_for <- temp_master_for %>% 
    mutate(total = sum(n_of_sub), 
           perc_per_action = round(n_of_sub/total*100, digits=2))
  print(temp_master_for$endowment)
  # list
  list_plot[[n]] <- ggplot(temp_master_for, 
                           aes(x=choice, 
                               y=perc_per_action)) + 
    geom_bar(stat = "identity") + 
    labs(title = i, 
         subtitle = temp_master_for$TreatmentName_paper[temp_master_for$treatment_id == i]) +
    xlim(min(choices_dg %>% filter(treatment_id==i) %>% dplyr::select(scenarios))-1,
         max(choices_dg %>% filter(treatment_id==i) %>% dplyr::select(scenarios))+1) +
    ylim(0,100) +
    xlab("Choice") + 
    ylab("Subjects (%)")
  
  n=n+1
}

# merge plots in one figure
do.call('grid.arrange',c(list_plot, ncol = 2))
```

### Consistency and Specificity {.tabset .tabset-pills}

<!-- tab: consistency, specificity -->

<!-- #### Formulas -->

<!-- $$ consistency = \frac{1}{\sigma_n}$$ -->

<!-- $$ specificity = \frac{\#\ of\ negative\ actions}{\#\ of\ positive\ actions}$$ -->

#### Consistency

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
# interpolation of appropriateness with scenarios out of game
beliefs_only_kim <- beliefs_dg %>%
  filter(paper_id == "2016Kim003" & treatment_id == "2016Kim003_7") %>%
  dplyr::select(paper_id, treatment_id, subject_id, scenarios, KW_Normative) %>%
  mutate(KW_Normative_temp = KW_Normative)

n_subj = length(levels(as.factor(beliefs_only_kim$subject_id)))

kim003_interpolation <- data.frame(paper_id=NA,
                           treatment_id=NA,
                           subject_id = NA,
                           scenarios=NA,
                           KW_Normative=NA,
                           KW_Normative_temp=NA)

for (subj in levels(as.factor(beliefs_only_kim$subject_id))) {
  subj_df <- data.frame(paper_id="2016Kim003",
                        treatment_id="2016Kim003_7",
                        subject_id = subj,
                        scenarios=seq(1,15,2),
                        KW_Normative = NA,
                        KW_Normative_temp=NA)
  
  subj_beliefs <- beliefs_only_kim %>%
    filter(subject_id == subj)
  #print(subj_beliefs)
  
  subj_beliefs <- subj_beliefs %>%
    rbind.data.frame(subj_df) %>%
    arrange(paper_id, treatment_id, subject_id, scenarios) %>%
    mutate(KW_Normative = na.approx(KW_Normative_temp,
                                    maxgap = 1,
                                    rule = 1))
  
  kim003_interpolation <- subj_beliefs %>%
    rbind.data.frame(kim003_interpolation)
  #print(kim003_interpolation)
}

# # how many scenarios are there for each subject in kim003_interpolation dataframe?
# kim003_interpolation %>% filter(paper_id=="2016Kim003" & treatment_id == "2016Kim003_7") %>% 
#   group_by(subject_id) %>% 
#   summarise(n_scen=length(scenarios)) %>%
#   group_by(n_scen) %>%
#   summarise(n_subjs = length(subject_id))

# # how many scenarios are there for each subject in beliefs_dg datafreme?
# beliefs_dg %>% filter(paper_id=="2016Kim003" & treatment_id == "2016Kim003_7") %>% 
#   group_by(subject_id) %>% 
#   summarise(n_scen=length(scenarios)) %>%
#   group_by(n_scen) %>%
#   summarise(n_subjs = length(subject_id))

# dataset to plot consistency
df_consistency_beliefs <- beliefs_dg %>%
  dplyr::select(paper_id, treatment_id, subject_id, scenarios, KW_Normative) %>%
  filter(treatment_id %in% levels(as.factor(master_dg$treatment_id))) %>%
  filter(paper_id != "2016Kim003") %>%
  rbind.data.frame(kim003_interpolation %>% dplyr::select(-KW_Normative_temp)) %>%
  merge.data.frame(master_dg %>%
                     subset.data.frame(dplyr::select = c(treatment_id,
                                                  max_sigma)),
                   by="treatment_id") 
# %>%
#   group_by(treatment_id, scenarios) %>%
#   summarise(sd = sd(KW_Normative),
#             max_sigma = max_sigma,
#             appropriateness = sum(KW_Normative)) %>%
#   mutate(consistency = 1-(sd/max_sigma))

scenarios_w_max_appropriateness <- beliefs_dg %>%
  group_by(treatment_id, scenarios) %>%
  summarise(KW=mean(KW_Normative)) %>%
  summarise(scenarios=scenarios[which(KW==max(KW))])

output <- merge.data.frame(scenarios_w_max_appropriateness,
                           df_consistency_beliefs,
                           all.x = T,
                           by=c("treatment_id", "scenarios"))

# # are there the same subjects between output and beliefs_dg?
# o <- output %>% group_by(treatment_id) %>% summarise(n_o=n())
# beliefs_dg %>% filter(scenarios==0) %>% group_by(treatment_id) %>% summarise(n_b=n()) %>% merge.data.frame(o) %>% mutate(test=ifelse(n_b-n_o==0,"ok","n"))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
ggplot(output,
       aes(x=treatment_id,
           y=KW_Normative)) +
  geom_boxplot() +
  labs(title="Distribution of appropriateness of most appropriate action (norm)") +
  xlab("Paper") +
  scale_y_continuous(limits = quantile(output$KW_Normative, c(0.1, 0.9))) + ylab("Appropriateness")

ggplot(output,
       aes(x=KW_Normative)) +
  geom_density() +
  facet_wrap(~treatment_id, ncol=2)
```

#### Specificity

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}

df_specificity_per_subject <- beliefs_dg %>% 
  group_by(subject_id) %>% 
  mutate(n_actions_positive = sum(KW_Normative>0), 
         n_actions_negative=sum(KW_Normative<=0), 
         specificity = n_actions_negative/n_actions_positive)

#box plot of specificity
ggplot(df_specificity_per_subject, 
       aes(x=treatment_id, 
           y=specificity)) + 
  geom_boxplot() + 
  labs(title="Boxplot of specificity per paper") +
  xlab("Paper") + 
  ylab("Specificity")

```

### Individual-level analyses {.tabset .tabset-pills}

#### Social Expectation Model

$U_{ik} = \delta \pi_k + \gamma A_k + \epsilon_{ik}$

-   $\pi_k$ indicates the payoff
-   $A_k$ indicates the norm appropriateness

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
mean_beliefs <- df_consistency_beliefs %>%
  group_by(treatment_id, scenarios) %>%
  summarise(mean_app = mean(KW_Normative),
            sd_app = sd(KW_Normative))

utility_df_treatment <- choices_dg %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  mutate(payoff = endowment - scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app)

utility_df_treatment$id = utility_df_treatment %>% group_indices(subject_id)

# dataset without Her061, missing age and gender
utility_df_treatment_demo <- utility_df_treatment %>%
  filter(!(paper_id %in% c("2018Her061", "2007Lis165", "2012Laz164", "2013Kru001")))

betas_se_logit <- data.frame(paper = NA, delta=NA, gamma=NA, SE_delta=NA, SE_gamma=NA, MRS=NA)

# mlogit
model_se_list <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_se=mclogit::mclogit(cbind(A,choice) ~ payoff + mean_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_se_list[[n_model]] = model_se
  n_model = n_model + 1

  betas_se_logit <- betas_se_logit %>% 
    rbind.data.frame(data.frame(paper = i, 
                                delta = as.numeric(model_se$coefficients[1]),
                                gamma=as.numeric(model_se$coefficients[2]),
                                SE_delta=coef(summary(model_se))[1, "Std. Error"],
                                SE_gamma=coef(summary(model_se))[2, "Std. Error"],
                                MRS = 2*as.numeric(model_se$coefficients[2])/as.numeric(model_se$coefficients[1])))
}

# mlogit gender
model_list_gender <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment_demo$treatment_id))) {
  print(i)
  model_se_gender=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:female, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  model_list_gender[[n_model]] = model_se_gender
  n_model = n_model +1
}

# mlogit age
model_list_age <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment_demo$treatment_id))) {
  print(i)
  model_se_age=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:age, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  model_list_age[[n_model]] = model_se_age
  n_model = n_model +1
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
opts <- options(knitr.kable.NA = "")
kbl(betas_se_logit,
    digits = 4, 
    booktabs = T, 
    align = "lcccc", 
    centering = F, 
    caption="Coefficients for Social Expectation model") %>%
  kable_styling(position = "left", 
                full_width = F) %>%
  column_spec(1, bold = T)

ggplot(betas_se_logit %>% filter(!(is.na(beta))) %>% arrange(gamma), aes(x=gamma,y=paper)) + 
  geom_point() + 
  geom_errorbar(aes(xmin=gamma-2*SE_gamma,xmax=gamma+2*SE_gamma))
```

<br> <br> **Model Estimates** <br> *Standard* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#standard
tab_model(model_se_list, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation")
```

<br> <br> *Gender* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#gender
tab_model(model_list_gender, dv.labels = levels(as.factor(utility_df_treatment_demo$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation with gender")
```

<br> <br> *Age* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#age
tab_model(model_list_age, dv.labels = levels(as.factor(utility_df_treatment_demo$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation with age")
```

#### Social Expectation Augmented Model

$U_{ik} = \alpha \pi_k + \beta A_k + \delta C_k + \epsilon_{ik}$

-   $\pi_k$ indicates the payoff
-   $A_k$ indicates the norm appropriateness
-   $C_k$ indicates the consistency

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
betas_sea_logit <- data.frame(paper = NA, alpha=NA, beta=NA, delta=NA, SE_alpha=NA, SE_beta=NA, SE_delta=NA, MRS=NA)
model_list_sea <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea=mclogit::mclogit(cbind(A,choice)~ payoff + sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea[[n_model]] = model_sea
  n_model = n_model +1  
  
  # betas_sea_logit <- betas_sea_logit %>% 
  #   rbind.data.frame(data.frame(paper = i, 
  #                               alpha = as.numeric(model_sea$coefficients[1]),
  #                               beta=as.numeric(model_sea$coefficients[2]),
  #                               delta=as.numeric(model_sea$coefficients[3]),
  #                               SE_alpha=coef(summary(model_sea))[1, "Std. Error"],
  #                               SE_beta=coef(summary(model_sea))[2, "Std. Error"],
  #                               SE_delta=coef(summary(model_sea))[3, "Std. Error"],
  #                               MRS = 2*as.numeric(model_sea$coefficients[2])/as.numeric(model_sea$coefficients[1])))
}

model_list_sea1 <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea1=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea1[[n_model]] = model_sea1
  n_model = n_model +1  
}

model_list_sea2 <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea2=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app*sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea2[[n_model]] = model_sea2
  n_model = n_model +1  
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
# opts <- options(knitr.kable.NA = "")
# kbl(betas_sea_logit,
#     digits = 4, 
#     booktabs = T, 
#     align = "lcccc", 
#     centering = F, 
#     caption="Coefficients for model with std") %>%
#   kable_styling(position = "left", 
#                 full_width = F) %>%
#   column_spec(1, bold = T)

tab_model(model_list_sea, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates")
tab_model(model_list_sea1, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates")
tab_model(model_list_sea2, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates")

# ggplot(betas_sea_logit %>% filter(!(is.na(beta))) %>% arrange(beta), aes(x=beta,y=paper)) + 
#   geom_point() + 
#   geom_errorbar(aes(xmin=beta-2*SE_beta,xmax=beta+2*SE_beta))
# 
# ggplot(betas_sea_logit %>% filter(!(is.na(delta))) %>% arrange(delta), aes(x=delta,y=paper)) + 
#   geom_point() + 
#   geom_errorbar(aes(xmin=delta-2*SE_delta,xmax=delta+2*SE_delta))
```



#### Inequality Aversion model (Fehr & Schimdt 1999)

$U_{ik} = \pi_k - \alpha*max( \pi_{jk} - \pi_{ik}) - \beta*max( \pi_{ik} - \pi_{jk})$

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
choices_df_sp <- choices_dg %>% mutate(payoff=endowment-scenarios,
                              other_payoff_ahead=ifelse(payoff-scenarios>0,payoff-scenarios,0),
                              other_payoff_behind=ifelse(scenarios-payoff>0,scenarios-payoff,0))

utility_df_treatment_sp <- choices_df_sp %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app) 

utility_df_treatment_sp$id = utility_df_treatment_sp %>% group_indices(subject_id)


# mlogit

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2016Kim003_7" & subject_id != "2016Kim003_7_2222"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper1 <- mlogit(A~ other_payoff_ahead + other_payoff_behind| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2018Her061_9"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper2 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2019Cha026_1"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper3 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2020Bas115_2a"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper4 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2007Lis165_1a"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper5 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2012Laz164_3"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper6 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2013Kru001_1a"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper7 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

list_model = list(ml.paper1, ml.paper2, ml.paper3, ml.paper4, ml.paper5, ml.paper6, ml.paper7)
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
tab_model(list_model, dv.labels = c("2016Kim003_7", "2018Her061_9", "2019Cha026_1", "2020Bas115_2a", "2007Lis165_1a", "2012Laz164_3", "2013Kru001"), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates", transform=NULL)
```

#### Inequality Aversion & Social Expectation model

$U_{ik} = \pi_k - \alpha*max( \pi_{jk} - \pi_{ik}) - \beta*max( \pi_{ik} - \pi_{jk}) +\delta A_k$

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
choices_df_sp <- choices_dg %>% mutate(payoff=endowment-scenarios,
                              other_payoff_ahead=ifelse(payoff-scenarios>0,payoff-scenarios,0),
                              other_payoff_behind=ifelse(scenarios-payoff>0,scenarios-payoff,0))

utility_df_treatment_sp <- choices_df_sp %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app) 

utility_df_treatment_sp$id = utility_df_treatment_sp %>% group_indices(subject_id)


# mlogit

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2016Kim003_7" & subject_id != "2016Kim003_7_2222"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper1 <- mlogit(A~ other_payoff_ahead + other_payoff_behind + mean_app| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2018Her061_9"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper2 <- mlogit(A~other_payoff_ahead + other_payoff_behind  + mean_app| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2019Cha026_1"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper3 <- mlogit(A~other_payoff_ahead + other_payoff_behind  + mean_app| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2020Bas115_2a"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper4 <- mlogit(A~other_payoff_ahead + other_payoff_behind  + mean_app| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2007Lis165_1a"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper5 <- mlogit(A~other_payoff_ahead + other_payoff_behind  + mean_app| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2012Laz164_3"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper6 <- mlogit(A~other_payoff_ahead + other_payoff_behind  + mean_app| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2013Kru001_1a"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper7 <- mlogit(A~other_payoff_ahead + other_payoff_behind  + mean_app| 0, df)

list_model = list(ml.paper1, ml.paper2, ml.paper3, ml.paper4, ml.paper5, ml.paper6, ml.paper7)
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
tab_model(list_model, dv.labels = c("2016Kim003_7", "2018Her061_9", "2019Cha026_1", "2020Bas115_2a", "2007Lis165_1a", "2012Laz164_3", "2013Kru001"), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates", transform=NULL)
```



## Take or Give Game {.tabset .tabset-pills}

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
# subset of dg data
master_tog <- master %>% 
  filter(Game_type == "ToG") %>%
  subset.data.frame(subset = !(Standard_game %in% c("N")) & 
                      Choice_Method != "OnlyNorms" & 
                      StatusTreatment_Roma == "6-Complete") %>% 
  mutate(treatment_id = paste(PaperID,"_",TreatmentCode,sep=""))

# list of treatments in target
list_of_paper_in_target <- master_tog %>% 
                    dplyr::select(PaperID, TreatmentCode, TreatmentName_paper, 
                               Year, Game_type, Standard_game, 
                               Baseline, Group_size, Rounds, 
                               Method_elicitation, Avg_coop, Avg_NE, 
                               Var_coop, Var_NE, Avg_KW_m)

# read file beliefs and choices
beliefs_tog <- beliefs %>%
  filter(treatment_id %in% levels(as.factor(paste(master_tog$PaperID,"_",master_tog$TreatmentCode, sep=""))))

choices_tog <- choices  %>%
  filter(treatment_id %in% levels(as.factor(paste(master_tog$PaperID,"_",master_tog$TreatmentCode, sep=""))))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# print table of "list_of_paper_in_target"
opts <- options(knitr.kable.NA = "")
kbl(list_of_paper_in_target,
    digits = 4, 
    booktabs = T, 
    align = "llllllllllrrrrrr", 
    centering = F, 
    caption="List of paper after selection criteria applied") %>%
  kable_styling(position = "left", 
                full_width = F) %>%
  column_spec(1, bold = T)
```
### Descriptive Plots {.tabset .tabset-pills}

#### Beliefs

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}

TOG_avg_kw <-  df_avg_kw %>% merge.data.frame(master_tog %>% 
                                               subset.data.frame(dplyr::select = c(PaperID, 
                                                                            TreatmentName_paper, 
                                                                            TreatmentCode, 
                                                                            treatment_id)), 
                                             by = c("PaperID","TreatmentCode","treatment_id")) %>% 
  filter(!(is.na(TreatmentName_paper)))
temp_master <- TOG_avg_kw %>% 
  distinct(treatment_id)

# inizializing variable for loop
n=1
list_plot <- c()

# creation of a plots list
for (i in temp_master$treatment_id) {
  
  # dataset
  temp_master_for <- TOG_avg_kw %>% 
    filter(treatment_id == i)
  
  # list
  list_plot[[n]] <- ggplot(temp_master_for, 
                           aes(x=donation, y=Kw_m)) + 
    geom_bar(stat = "identity") + 
    labs(title = i, 
         subtitle = temp_master_for$TreatmentName_paper[temp_master_for$treatment_id == i]) +
    ylim(-1,1) +
    xlim(-6,6) +
    xlab("Scenario") + 
    ylab("Appropriateness (average)")
  
  n=n+1
}

# merge plots in one figure
do.call('grid.arrange', 
        c(list_plot, ncol = 2))
```

#### Choices

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=10}
# dataset
perc_choices <- choices_tog %>% 
  filter(A==1) %>% 
  group_by(treatment_id, choice) %>% 
  summarise(n_of_sub = n(),
            endowment = mean(endowment)) %>%
  merge.data.frame(master_tog %>% 
                     subset.data.frame(dplyr::select = c(PaperID, TreatmentName_paper, 
                                                  TreatmentCode, treatment_id)), 
                   by = "treatment_id") %>% 
  filter(!(is.na(TreatmentName_paper)))

temp_master <- choices_tog %>% 
  distinct(treatment_id)

# inizializing variables for loop
n=1
list_plot <- c()

# creation of a plots list
for (i in temp_master$treatment_id) {
  
  # dataset
  temp_master_for <- perc_choices %>% 
    filter(treatment_id == i)
  temp_master_for <- temp_master_for %>% 
    mutate(total = sum(n_of_sub), 
           perc_per_action = round(n_of_sub/total*100, digits=2))
  print(temp_master_for$endowment)
  # list
  list_plot[[n]] <- ggplot(temp_master_for, 
                           aes(x=choice, 
                               y=perc_per_action)) + 
    geom_bar(stat = "identity") + 
    labs(title = i, 
         subtitle = temp_master_for$TreatmentName_paper[temp_master_for$treatment_id == i]) +
    xlim(min(choices_tog %>% filter(treatment_id==i) %>% dplyr::select(scenarios))-1,
         max(choices_tog %>% filter(treatment_id==i) %>% dplyr::select(scenarios))+1) +
    ylim(0,100) +
    xlab("Choice") + 
    ylab("Subjects (%)")
  
  n=n+1
}

# merge plots in one figure
do.call('grid.arrange',c(list_plot, ncol = 2))
```


### Consistency and Specificity {.tabset .tabset-pills}

#### Consistency
```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# dataset to plot consistency
df_consistency_beliefs <- beliefs_tog %>%
  dplyr::select(paper_id, treatment_id, subject_id, scenarios, KW_Normative) %>%
  merge.data.frame(master_tog %>%
                     subset.data.frame(dplyr::select = c(treatment_id,
                                                  max_sigma)),
                   by="treatment_id") 

scenarios_w_max_appropriateness <- beliefs_tog %>%
  group_by(treatment_id, scenarios) %>%
  summarise(KW=mean(KW_Normative)) %>%
  summarise(scenarios=scenarios[which(KW==max(KW))])

output <- merge.data.frame(scenarios_w_max_appropriateness,
                           df_consistency_beliefs,
                           all.x = T,
                           by=c("treatment_id", "scenarios"))

# # are there the same subjects between output and beliefs_dg?
# o <- output %>% group_by(treatment_id) %>% summarise(n_o=n())
# beliefs_dg %>% filter(scenarios==0) %>% group_by(treatment_id) %>% summarise(n_b=n()) %>% merge.data.frame(o) %>% mutate(test=ifelse(n_b-n_o==0,"ok","n"))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 10, fig.height=10}
ggplot(output,
       aes(x=treatment_id,
           y=KW_Normative)) +
  geom_boxplot() +
  labs(title="Distribution of appropriateness of most appropriate action (norm)") +
  xlab("Paper") +
  scale_y_continuous(limits = quantile(output$KW_Normative, c(0.1, 0.9))) + ylab("Appropriateness")

ggplot(output,
       aes(x=KW_Normative)) +
  geom_density() +
  facet_wrap(~treatment_id, ncol=2)
```

#### Specificity

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}

df_specificity_per_subject <- beliefs_tog %>% 
  group_by(subject_id) %>% 
  mutate(n_actions_positive = sum(KW_Normative>0), 
         n_actions_negative=sum(KW_Normative<=0), 
         specificity = n_actions_negative/n_actions_positive)

#box plot of specificity
ggplot(df_specificity_per_subject, 
       aes(x=treatment_id, 
           y=specificity)) + 
  geom_boxplot() + 
  labs(title="Boxplot of specificity per paper") +
  xlab("Paper") + 
  ylab("Specificity")

```

### Individual-level analysis {.tabset .tabset-pills}

#### Social Expectation Model

$U_{ik} = \delta \pi_k + \gamma A_k + \epsilon_{ik}$

-   $\pi_k$ indicates the payoff
-   $A_k$ indicates the norm appropriateness

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
mean_beliefs <- df_consistency_beliefs %>%
  group_by(treatment_id, scenarios) %>%
  summarise(mean_app = mean(KW_Normative),
            sd_app = sd(KW_Normative))

utility_df_treatment <- choices_tog %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  mutate(payoff = endowment - scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app)

utility_df_treatment$id = utility_df_treatment %>% group_indices(subject_id)

# dataset without paper with missing age and gender
utility_df_treatment_demo <- utility_df_treatment %>%
  filter(!(paper_id %in% c("2007Lis165", "2013Kru001")))

betas_se_logit <- data.frame(paper = NA, delta=NA, gamma=NA, SE_delta=NA, SE_gamma=NA, MRS=NA)

# mlogit
model_se_list <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_se=mclogit::mclogit(cbind(A,choice) ~ payoff + mean_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  model_se_list[[n_model]] = model_se
  n_model = n_model + 1

  betas_se_logit <- betas_se_logit %>% 
    rbind.data.frame(data.frame(paper = i, 
                                delta = as.numeric(model_se$coefficients[1]),
                                gamma=as.numeric(model_se$coefficients[2]),
                                SE_delta=coef(summary(model_se))[1, "Std. Error"],
                                SE_gamma=coef(summary(model_se))[2, "Std. Error"],
                                MRS = 2*as.numeric(model_se$coefficients[2])/as.numeric(model_se$coefficients[1])))
}

# mlogit gender
model_list_gender <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment_demo$treatment_id))) {
  print(i)
  model_se_gender=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:female, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  model_list_gender[[n_model]] = model_se_gender
  n_model = n_model +1
}

# mlogit age
model_list_age <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment_demo$treatment_id))) {
  print(i)
  model_se_age=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:age, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  model_list_age[[n_model]] = model_se_age
  n_model = n_model +1
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
opts <- options(knitr.kable.NA = "")
kbl(betas_se_logit,
    digits = 4, 
    booktabs = T, 
    align = "lcccc", 
    centering = F, 
    caption="Coefficients for Social Expectation model") %>%
  kable_styling(position = "left", 
                full_width = F) %>%
  column_spec(1, bold = T)

ggplot(betas_se_logit %>% filter(!(is.na(delta))) %>% arrange(delta), aes(x=delta,y=paper)) + 
  geom_point() + 
  geom_errorbar(aes(xmin=gamma-2*SE_gamma,xmax=gamma+2*SE_gamma))
```

<br> <br> **Model Estimates** <br> *Standard* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#standard
tab_model(model_se_list, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation")
```

<br> <br> *Gender* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#gender
tab_model(model_list_gender, dv.labels = levels(as.factor(utility_df_treatment_demo$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation with gender")
```

<br> <br> *Age* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#age
tab_model(model_list_age, dv.labels = levels(as.factor(utility_df_treatment_demo$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation with age")
```

#### Social Expectation Augmented Model

$U_{ik} = \alpha \pi_k + \beta A_k + \delta C_k + \epsilon_{ik}$

-   $\pi_k$ indicates the payoff
-   $A_k$ indicates the norm appropriateness
-   $C_k$ indicates the standard deviation

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
betas_sea_logit <- data.frame(paper = NA, alpha=NA, beta=NA, delta=NA, SE_alpha=NA, SE_beta=NA, SE_delta=NA, MRS=NA)
model_list_sea <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
# for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
#   model_sea=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app, data=utility_df_treatment%>% 
#                            filter(treatment_id==i))
#   
#   model_list_sea[[n_model]] = model_sea
#   n_model = n_model +1  
  
  # betas_sea_logit <- betas_sea_logit %>% 
  #   rbind.data.frame(data.frame(paper = i, 
  #                               alpha = as.numeric(model_sea$coefficients[1]),
  #                               beta=as.numeric(model_sea$coefficients[2]),
  #                               delta=as.numeric(model_sea$coefficients[3]),
  #                               SE_alpha=coef(summary(model_sea))[1, "Std. Error"],
  #                               SE_beta=coef(summary(model_sea))[2, "Std. Error"],
  #                               SE_delta=coef(summary(model_sea))[3, "Std. Error"],
  #                               MRS = 2*as.numeric(model_sea$coefficients[2])/as.numeric(model_sea$coefficients[1])))
# }

model_list_sea1 <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea1=mclogit::mclogit(cbind(A,choice)~ payoff + sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea1[[n_model]] = model_sea1
  n_model = n_model +1  
}

model_list_sea2 <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea2=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea2[[n_model]] = model_sea2
  n_model = n_model +1  
}

model_list_sea3 <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea3=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app*sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea3[[n_model]] = model_sea3
  n_model = n_model +1  
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center"}
# opts <- options(knitr.kable.NA = "")
# kbl(betas_sea_logit,
#     digits = 4, 
#     booktabs = T, 
#     align = "lcccc", 
#     centering = F, 
#     caption="Coefficients for model with std") %>%
#   kable_styling(position = "left", 
#                 full_width = F) %>%
#   column_spec(1, bold = T)

# tab_model(model_list_sea, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates mean_app")
tab_model(model_list_sea1, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates sd_app")
tab_model(model_list_sea2, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates mean_app:sd_app")
tab_model(model_list_sea3, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates mean_app:sd_app")

# ggplot(betas_sea_logit %>% filter(!(is.na(beta))) %>% arrange(beta), aes(x=beta,y=paper)) + 
#   geom_point() + 
#   geom_errorbar(aes(xmin=beta-2*SE_beta,xmax=beta+2*SE_beta))
# 
# ggplot(betas_sea_logit %>% filter(!(is.na(delta))) %>% arrange(delta), aes(x=delta,y=paper)) + 
#   geom_point() + 
#   geom_errorbar(aes(xmin=delta-2*SE_delta,xmax=delta+2*SE_delta))

ggplot(data=utility_df_treatment, aes(x=mean_app, y=sd_app)) + geom_point() + geom_smooth() + geom_jitter()
```

#### Inequality Aversion model (Fehr & Schimdt 1999)

$U_{ik} = \pi_k - \alpha*max( \pi_{jk} - \pi_{ik}) - \beta*max( \pi_{ik} - \pi_{jk})$

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
choices_df_sp <- choices_tog %>% mutate(payoff=endowment-scenarios,
                              other_payoff_ahead=ifelse(payoff-scenarios>0,payoff-scenarios,0),
                              other_payoff_behind=ifelse(scenarios-payoff>0,scenarios-payoff,0))

utility_df_treatment_sp <- choices_df_sp %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app) 

utility_df_treatment_sp$id = utility_df_treatment_sp %>% group_indices(subject_id)


# mlogit

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2007Lis165_1b"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper1 <- mlogit(A~ other_payoff_ahead + other_payoff_behind| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2013Kru001_1b"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper2 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2019Cha026_3"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper3 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)


list_model = list(ml.paper1, ml.paper2, ml.paper3)
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
tab_model(list_model, dv.labels = c("2007Lis165_1b", "2013Kru001_1b", "2019Cha026_3"), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates", transform=NULL)
```


## Donation Game {.tabset .tabset-pills}

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
# subset of dg data
master_don <- master %>% 
  filter(Game_type == "Donation Game") %>%
  subset.data.frame(subset = !(Standard_game %in% c("N")) & 
                      Choice_Method != "OnlyNorms" & 
                      StatusTreatment_Roma == "6-Complete" & 
                      Baseline %in% c(NA, 1)) %>% 
  mutate(treatment_id = paste(PaperID,"_",TreatmentCode,sep=""))

# list of treatments in target
list_of_paper_in_target <- master_don %>% 
                    dplyr::select(PaperID, TreatmentCode, TreatmentName_paper, 
                               Year, Game_type, Standard_game, 
                               Baseline, Group_size, Rounds, 
                               Method_elicitation, Avg_coop, Avg_NE, 
                               Var_coop, Var_NE, Avg_KW_m)

# read file beliefs and choices
beliefs_don <- beliefs %>%
  filter(treatment_id %in% levels(as.factor(paste(master_don$PaperID,"_",master_don$TreatmentCode, sep=""))))

choices_don <- choices  %>%
  filter(treatment_id %in% levels(as.factor(paste(master_don$PaperID,"_",master_don$TreatmentCode, sep=""))))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# print table of "list_of_paper_in_target"
opts <- options(knitr.kable.NA = "")
kbl(list_of_paper_in_target,
    digits = 4, 
    booktabs = T, 
    align = "llllllllllrrrrrr", 
    centering = F, 
    caption="List of paper after selection criteria applied") %>%
  kable_styling(position = "left", 
                full_width = F) %>%
  column_spec(1, bold = T)
```

### Descriptive Plots {.tabset .tabset-pills}

<!-- tab: beliefs, choices -->

#### Beliefs

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14}

DON_avg_kw <- df_avg_kw %>% merge.data.frame(master_don %>% 
                                               subset.data.frame(dplyr::select = c(PaperID, 
                                                                            TreatmentName_paper, 
                                                                            TreatmentCode, 
                                                                            treatment_id)), 
                                             by = c("PaperID","TreatmentCode","treatment_id")) %>% 
  filter(!(is.na(TreatmentName_paper)))
temp_master <- DON_avg_kw %>% 
  distinct(treatment_id)

# inizializing variable for loop
n=1
list_plot <- c()

# creation of a plots list
for (i in temp_master$treatment_id) {
  
  # dataset
  temp_master_for <- DON_avg_kw %>% 
    filter(treatment_id == i)
  
  # list
  list_plot[[n]] <- ggplot(temp_master_for, 
                           aes(x=donation, y=Kw_m)) + 
    geom_bar(stat = "identity") + 
    labs(title = i, 
         subtitle = temp_master_for$TreatmentName_paper[temp_master_for$treatment_id == i]) +
    ylim(-1,1) +
    xlab("Scenario") + 
    ylab("Appropriateness (average)")
  
  n=n+1
}

# merge plots in one figure
do.call('grid.arrange', 
        c(list_plot, ncol = 2))
```

#### Choices

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14}
# dataset
perc_choices <- choices_don %>% 
  filter(A==1) %>% 
  group_by(treatment_id, choice) %>% 
  summarise(n_of_sub = n(),
            endowment = mean(endowment)) %>%
  merge.data.frame(master_don %>% 
                     subset.data.frame(dplyr::select = c(PaperID, TreatmentName_paper, 
                                                  TreatmentCode, treatment_id)), 
                   by = "treatment_id") %>% 
  filter(!(is.na(TreatmentName_paper)))

temp_master <- choices_don %>% 
  distinct(treatment_id)

# inizializing variables for loop
n=1
list_plot <- c()

# creation of a plots list
for (i in temp_master$treatment_id) {
  
  # dataset
  temp_master_for <- perc_choices %>% 
    filter(treatment_id == i)
  temp_master_for <- temp_master_for %>% 
    mutate(total = sum(n_of_sub), 
           perc_per_action = round(n_of_sub/total*100, digits=2))
  print(temp_master_for$endowment)
  # list
  list_plot[[n]] <- ggplot(temp_master_for, 
                           aes(x=choice, 
                               y=perc_per_action)) + 
    geom_bar(stat = "identity") + 
    labs(title = i, 
         subtitle = temp_master_for$TreatmentName_paper[temp_master_for$treatment_id == i]) +
    xlim(min(choices_don %>% filter(treatment_id==i) %>% dplyr::select(scenarios))-10,
         max(choices_don %>% filter(treatment_id==i) %>% dplyr::select(scenarios))+10) +
    ylim(0,100) +
    xlab("Choice") + 
    ylab("Subjects (%)")
  
  n=n+1
}

# merge plots in one figure
do.call('grid.arrange',c(list_plot, ncol = 2))
```

### Consistency and Specificity {.tabset .tabset-pills}

<!-- tab: consistency, specificity -->

<!-- #### Formulas -->

<!-- $$ consistency = \frac{1}{\sigma_n}$$ -->

<!-- $$ specificity = \frac{\#\ of\ negative\ actions}{\#\ of\ positive\ actions}$$ -->

#### Consistency

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
# dataset to plot consistency
df_consistency_beliefs <- beliefs_don %>%
  dplyr::select(paper_id, treatment_id, subject_id, scenarios, KW_Normative) %>%
  merge.data.frame(master_don %>%
                     subset.data.frame(dplyr::select = c(treatment_id,
                                                  max_sigma)),
                   by="treatment_id") 

scenarios_w_max_appropriateness <- beliefs_don %>%
  group_by(treatment_id, scenarios) %>%
  summarise(KW=mean(KW_Normative)) %>%
  summarise(scenarios=scenarios[which(KW==max(KW))])

output <- merge.data.frame(scenarios_w_max_appropriateness,
                           df_consistency_beliefs,
                           all.x = T,
                           by=c("treatment_id", "scenarios"))

```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14}
ggplot(output,
       aes(x=treatment_id,
           y=KW_Normative)) +
  geom_boxplot() +
  labs(title="Distribution of appropriateness of most appropriate action (norm)") +
  xlab("Paper") +
  scale_y_continuous(limits = quantile(output$KW_Normative, c(0.1, 0.9))) + ylab("Appropriateness")

ggplot(output,
       aes(x=KW_Normative)) +
  geom_density() +
  facet_wrap(~treatment_id, ncol=2)
```

#### Specificity

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}

df_specificity_per_subject <- beliefs_don %>% 
  group_by(subject_id) %>% 
  mutate(n_actions_positive = sum(KW_Normative>0), 
         n_actions_negative=sum(KW_Normative<=0), 
         specificity = n_actions_negative/n_actions_positive)

#box plot of specificity
ggplot(df_specificity_per_subject, 
       aes(x=treatment_id, 
           y=specificity)) + 
  geom_boxplot() + 
  labs(title="Boxplot of specificity per paper") +
  xlab("Paper") + 
  ylab("Specificity")

```

### Individual-level analyses {.tabset .tabset-pills}

#### Social Expectation Model

$U_{ik} = \delta \pi_k + \gamma A_k + \epsilon_{ik}$

-   $\pi_k$ indicates the payoff
-   $A_k$ indicates the norm appropriateness

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
mean_beliefs <- df_consistency_beliefs %>%
  group_by(treatment_id, scenarios) %>%
  summarise(mean_app = mean(KW_Normative),
            sd_app = sd(KW_Normative))

utility_df_treatment <- choices_don %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  mutate(payoff = endowment - scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app)

utility_df_treatment$id = utility_df_treatment %>% group_indices(subject_id)

betas_se_logit <- data.frame(paper = NA, delta=NA, gamma=NA, SE_delta=NA, SE_gamma=NA, MRS=NA)

# mlogit
model_se_list <- list()
n_model = 1
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_se=mclogit::mclogit(cbind(A,choice) ~ payoff + mean_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  model_se_list[[n_model]] = model_se
  n_model = n_model + 1

  betas_se_logit <- betas_se_logit %>% 
    rbind.data.frame(data.frame(paper = i, 
                                delta = as.numeric(model_se$coefficients[1]),
                                gamma=as.numeric(model_se$coefficients[2]),
                                SE_delta=coef(summary(model_se))[1, "Std. Error"],
                                SE_gamma=coef(summary(model_se))[2, "Std. Error"],
                                MRS = 2*as.numeric(model_se$coefficients[2])/as.numeric(model_se$coefficients[1])))
}

```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
opts <- options(knitr.kable.NA = "")
kbl(betas_se_logit,
    digits = 4, 
    booktabs = T, 
    align = "lcccc", 
    centering = F, 
    caption="Coefficients for Social Expectation model") %>%
  kable_styling(position = "left", 
                full_width = F) %>%
  column_spec(1, bold = T)

ggplot(betas_se_logit %>% filter(!(is.na(delta))) %>% arrange(delta), aes(x=delta,y=paper)) + 
  geom_point() + 
  geom_errorbar(aes(xmin=gamma-2*SE_gamma,xmax=gamma+2*SE_gamma))
```

<br> <br> **Model Estimates** <br> *Standard* <br>

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
#standard
tab_model(model_se_list, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model estimates for social expectation")
```


#### Social Expectation Augmented Model

$U_{ik} = \alpha \pi_k + \beta A_k + \delta C_k + \epsilon_{ik}$

-   $\pi_k$ indicates the payoff
-   $A_k$ indicates the norm appropriateness
-   $C_k$ indicates the consistency

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
betas_sea_logit <- data.frame(paper = NA, alpha=NA, beta=NA, delta=NA, SE_alpha=NA, SE_beta=NA, SE_delta=NA, MRS=NA)
model_list_sea <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea=mclogit::mclogit(cbind(A,choice)~ payoff + sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea[[n_model]] = model_sea
  n_model = n_model +1  
  
  # betas_sea_logit <- betas_sea_logit %>% 
  #   rbind.data.frame(data.frame(paper = i, 
  #                               alpha = as.numeric(model_sea$coefficients[1]),
  #                               beta=as.numeric(model_sea$coefficients[2]),
  #                               delta=as.numeric(model_sea$coefficients[3]),
  #                               SE_alpha=coef(summary(model_sea))[1, "Std. Error"],
  #                               SE_beta=coef(summary(model_sea))[2, "Std. Error"],
  #                               SE_delta=coef(summary(model_sea))[3, "Std. Error"],
  #                               MRS = 2*as.numeric(model_sea$coefficients[2])/as.numeric(model_sea$coefficients[1])))
}

model_list_sea1 <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea1=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app:sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea1[[n_model]] = model_sea1
  n_model = n_model +1  
}

model_list_sea2 <- list()
n_model = 1

# mlogit consistency on utility_df_treatment
for (i in levels(as.factor(utility_df_treatment$treatment_id))) {
  model_sea2=mclogit::mclogit(cbind(A,choice)~ payoff + mean_app + mean_app*sd_app, data=utility_df_treatment%>% 
                           filter(treatment_id==i))
  
  model_list_sea2[[n_model]] = model_sea2
  n_model = n_model +1  
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
# opts <- options(knitr.kable.NA = "")
# kbl(betas_sea_logit,
#     digits = 4, 
#     booktabs = T, 
#     align = "lcccc", 
#     centering = F, 
#     caption="Coefficients for model with std") %>%
#   kable_styling(position = "left", 
#                 full_width = F) %>%
#   column_spec(1, bold = T)

tab_model(model_list_sea, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates")
tab_model(model_list_sea1, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates")
tab_model(model_list_sea2, dv.labels = levels(as.factor(utility_df_treatment$treatment_id)), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates")

# ggplot(betas_sea_logit %>% filter(!(is.na(beta))) %>% arrange(beta), aes(x=beta,y=paper)) + 
#   geom_point() + 
#   geom_errorbar(aes(xmin=beta-2*SE_beta,xmax=beta+2*SE_beta))
# 
# ggplot(betas_sea_logit %>% filter(!(is.na(delta))) %>% arrange(delta), aes(x=delta,y=paper)) + 
#   geom_point() + 
#   geom_errorbar(aes(xmin=delta-2*SE_delta,xmax=delta+2*SE_delta))
```



#### Inequality Aversion model (Fehr & Schimdt 1999)

$U_{ik} = \pi_k - \alpha*max( \pi_{jk} - \pi_{ik}) - \beta*max( \pi_{ik} - \pi_{jk})$

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", include=FALSE}
choices_df_sp <- choices_don %>% mutate(payoff=endowment-scenarios,
                              other_payoff_ahead=ifelse(payoff-scenarios>0,payoff-scenarios,0),
                              other_payoff_behind=ifelse(scenarios-payoff>0,scenarios-payoff,0))

utility_df_treatment_sp <- choices_df_sp %>%
  merge.data.frame(mean_beliefs) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app) 

utility_df_treatment_sp$id = utility_df_treatment_sp %>% group_indices(subject_id)


# mlogit

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2020And089_1"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper1 <- mlogit(A~ other_payoff_ahead + other_payoff_behind| 0, df)

df <- mlogit.data(utility_df_treatment_sp %>% filter(treatment_id=="2020And089_2"),choice = "A", shape = "long", alt.var = "scenarios")
ml.paper2 <- mlogit(A~other_payoff_ahead + other_payoff_behind | 0, df)


list_model = list(ml.paper1, ml.paper2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.align="center", fig.width = 14, fig.height=14}
tab_model(list_model, dv.labels = c("2020And089_1", "2020And089_2"), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "Model Estimates", transform=NULL)
```


## AIC: Model Comparison {.tabset .tabset-pills}

```{r utility_df_treatment_aic_analysis, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
master_aic_analysis <- master %>% 
  filter(Game_type %in% c("DG")) %>%
  subset.data.frame(subset = !(Standard_game %in% c("N")) & 
                      Choice_Method != "OnlyNorms" & 
                      StatusTreatment_Roma == "6-Complete" & 
                      Baseline %in% c(NA, 1)) %>% 
  mutate(treatment_id = paste(PaperID,"_",TreatmentCode,sep=""))


# read file beliefs and choices
choices_aic_analysis <- choices  %>%
  filter(treatment_id %in% levels(as.factor(paste(master_aic_analysis$PaperID,"_",master_aic_analysis$TreatmentCode, sep=""))))

choices_aic_analysis <- choices_aic_analysis %>% mutate(payoff=endowment-scenarios,
                              other_payoff_ahead=-ifelse(payoff-scenarios>0,payoff-scenarios,0),
                              other_payoff_behind=-ifelse(scenarios-payoff>0,scenarios-payoff,0),
                              sqr_other_payoff_ahead=-other_payoff_ahead^2,
                              sqr_other_payoff_behind=-other_payoff_behind^2)

beliefs_aic_analysis <- beliefs %>%
  filter(treatment_id %in% levels(as.factor(paste(master_aic_analysis$PaperID,"_",master_aic_analysis$TreatmentCode, sep=""))))

beliefs_only_kim <- beliefs_aic_analysis %>%
  filter(paper_id == "2016Kim003" & treatment_id == "2016Kim003_7") %>%
  dplyr::select(paper_id, treatment_id, subject_id, scenarios, KW_Normative) %>%
  mutate(KW_Normative_temp = KW_Normative)

n_subj = length(levels(as.factor(beliefs_only_kim$subject_id)))

kim003_interpolation <- data.frame(paper_id=NA,
                           treatment_id=NA,
                           subject_id = NA,
                           scenarios=NA,
                           KW_Normative=NA,
                           KW_Normative_temp=NA)

for (subj in levels(as.factor(beliefs_only_kim$subject_id))) {
  subj_df <- data.frame(paper_id="2016Kim003",
                        treatment_id="2016Kim003_7",
                        subject_id = subj,
                        scenarios=seq(1,15,2),
                        KW_Normative = NA,
                        KW_Normative_temp=NA)
  
  subj_beliefs <- beliefs_only_kim %>%
    filter(subject_id == subj)
  #print(subj_beliefs)
  
  subj_beliefs <- subj_beliefs %>%
    rbind.data.frame(subj_df) %>%
    arrange(paper_id, treatment_id, subject_id, scenarios) %>%
    mutate(KW_Normative = na.approx(KW_Normative_temp,
                                    maxgap = 1,
                                    rule = 1))
  
  kim003_interpolation <- subj_beliefs %>%
    rbind.data.frame(kim003_interpolation)
}


beliefs_aic_analysis <- beliefs_aic_analysis %>%
  dplyr::select(paper_id, treatment_id, subject_id, scenarios, KW_Normative) %>%
  filter(paper_id != "2016Kim003") %>%
  rbind.data.frame(kim003_interpolation %>% dplyr::select(-KW_Normative_temp))
                              
mean_beliefs_aic_analysis <- beliefs_aic_analysis %>%
  group_by(treatment_id, scenarios) %>%
  summarise(mean_app = mean(KW_Normative),
            sd_app = sd(KW_Normative),
            log_sd_app = log(sd_app))

utility_df_treatment_aic_analysis <- choices_aic_analysis %>%
  merge.data.frame(mean_beliefs_aic_analysis) %>%
  arrange(paper_id,treatment_id,subject_id,scenarios) %>%
  relocate(paper_id,treatment_id,subject_id,scenarios,choice,A,endowment,
           payoff,mean_app,sd_app) 

utility_df_treatment_aic_analysis$id = utility_df_treatment_aic_analysis %>% group_indices(subject_id)


# function
comparison_aic = function(treatment) {
  df_master <- utility_df_treatment_aic_analysis %>% 
                                    filter(treatment_id==treatment)
  
  social_expectation_model=clogit(A ~ payoff + mean_app + strata(subject_id), 
                                  data=df_master)
  # boot.clogit <- function(data, indices){
  # new_data <- data[indices,] 
  # mod <- clogit(A ~ payoff + mean_app + strata(subject_id), data = new_data, x=T, y=T)
  # coefficients(mod)
  # }
  # 
  # boot_data <- boot(data=ciao, statistic=boot.clogit, R=1000)
  
  social_delta = as.numeric(social_expectation_model$coefficients[1])
  social_gamma = as.numeric(social_expectation_model$coefficients[2])
  social_delta_se = coef(summary(social_expectation_model))[1, "se(coef)"]
  social_gamma_se = coef(summary(social_expectation_model))[2, "se(coef)"]

  inequality_aversion_model=clogit(A ~ other_payoff_ahead + other_payoff_behind + strata(subject_id), 
                                  data=df_master)
  
  inequality_alpha = as.numeric(inequality_aversion_model$coefficients[1])
  inequality_beta = as.numeric(inequality_aversion_model$coefficients[2])
  inequality_alpha_se = coef(summary(inequality_aversion_model))[1, "se(coef)"]
  inequality_beta_se = coef(summary(inequality_aversion_model))[2, "se(coef)"]
  
  inequality_aversion_sqr_model=clogit(A ~ other_payoff_ahead + other_payoff_behind + sqr_other_payoff_ahead + strata(subject_id), 
                                  data=df_master)
  
  inequality_sqr_alpha = as.numeric(inequality_aversion_sqr_model$coefficients[1])
  inequality_sqr_beta = as.numeric(inequality_aversion_sqr_model$coefficients[2])
  inequality_sqr_alpha2 = as.numeric(inequality_aversion_sqr_model$coefficients[3])
  #inequality_sqr_beta2 = as.numeric(inequality_aversion_sqr_model$coefficients[4])
  inequality_sqr_alpha_se = coef(summary(inequality_aversion_sqr_model))[1, "se(coef)"]
  inequality_sqr_beta_se = coef(summary(inequality_aversion_sqr_model))[2, "se(coef)"]
  inequality_sqr_alpha2_se = coef(summary(inequality_aversion_sqr_model))[3, "se(coef)"]
  #inequality_sqr_beta2_se = coef(summary(inequality_aversion_sqr_model))[4, "se(coef)"]

  mixed_model=clogit(A ~ other_payoff_ahead + other_payoff_behind + mean_app + strata(subject_id), 
                                  data=df_master)
  
  mixed_alpha = as.numeric(mixed_model$coefficients[1])
  mixed_beta = as.numeric(mixed_model$coefficients[2])
  mixed_gamma = as.numeric(mixed_model$coefficients[3])
  mixed_alpha_se = coef(summary(mixed_model))[1, "se(coef)"]
  mixed_beta_se = coef(summary(mixed_model))[2, "se(coef)"]
  mixed_gamma_se = coef(summary(mixed_model))[3, "se(coef)"]

  models <- list(social_expectation_model,inequality_aversion_model, inequality_aversion_sqr_model, mixed_model)
  model.names <- c('social expectation', 'inequality aversion', "inequality sqr", "mixed")
  aic_comp_t <- aictab(cand.set = models, modnames = model.names)
  row.names(aic_comp_t) <- aic_comp_t[,1]
  paper_and_aic_coeff <- list(treatment, 
                              aic_comp_t,
                              social_delta,
                              social_gamma,
                              social_delta_se,
                              social_gamma_se,
                              inequality_alpha,
                              inequality_beta,
                              inequality_alpha_se,
                              inequality_beta_se,
                              inequality_sqr_alpha,
                              inequality_sqr_beta,
                              inequality_sqr_alpha2,
                              #inequality_sqr_beta2,
                              inequality_sqr_alpha_se,
                              inequality_sqr_beta_se,
                              inequality_sqr_alpha2_se,
                              #inequality_sqr_beta2_se,
                              mixed_alpha,
                              mixed_beta,
                              mixed_gamma,
                              mixed_alpha_se,
                              mixed_beta_se,
                              mixed_gamma_se,
                              models)
  names(paper_and_aic_coeff) <- c("treatment", 
                                  "aic_comp_t",
                                  "social_delta",
                                  "social_gamma",
                                  "social_delta_se",
                                  "social_gamma_se",
                                  "inequality_alpha",
                                  "inequality_beta",
                                  "inequality_alpha_se",
                                  "inequality_beta_se",
                                  "inequality_sqr_alpha",
                                  "inequality_sqr_beta",
                                  "inequality_sqr_alpha2",
                                  #"inequality_sqr_beta2",
                                  "inequality_sqr_alpha_se",
                                  "inequality_sqr_beta_se",
                                  "inequality_sqr_alpha2_se",
                                  #"inequality_sqr_beta2_se",
                                  "mixed_alpha",
                                  "mixed_beta",
                                  "mixed_gamma",
                                  "mixed_alpha_se",
                                  "mixed_beta_se",
                                  "mixed_gamma_se",
                                  "models")
  invisible(paper_and_aic_coeff)
}
```


```{r create table for aic and pointrange, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
aic_table <-data.frame()
social_coeff <- data.frame()
models <- list()
names_model <- c()

for (t in levels(as.factor(utility_df_treatment_aic_analysis$treatment_id))) {
  x = comparison_aic(t)
  treatment = x[[1]]
  delta_se_ia_aic = x[[2]][["social expectation",3]] - x[[2]][["inequality aversion",3]]
  delta_ia_iasqr_aic = x[[2]][["inequality aversion",3]] - x[[2]][["inequality sqr",3]]
  delta_se_iasqr_aic = x[[2]][["social expectation",3]] - x[[2]][["inequality sqr",3]]
  delta_se_mixed_aic = x[[2]][["social expectation",3]] - x[[2]][["mixed",3]]
  
  aic_table <- aic_table %>% 
    rbind.data.frame(data.frame(treatment_id = treatment, 
                                Delta_SE_IA_AIC = delta_se_ia_aic,
                                Delta_IA_IASQR_AIC = delta_ia_iasqr_aic,
                                Delta_SE_IASQR_AIC = delta_se_iasqr_aic,
                                Delta_SE_MIXED_AIC = delta_se_mixed_aic))
  
  social_coeff <- social_coeff %>% 
    rbind.data.frame(data.frame(treatment_id = treatment, 
                                i_alpha = x$inequality_alpha,
                                i_beta= x$inequality_beta,
                                ia_sqr_alpha = x$inequality_sqr_alpha,
                                ia_sqr_beta= x$inequality_sqr_beta,
                                ia_sqr_alpha2 = x$inequality_sqr_alpha2,
                                #ia_sqr_beta2= x$inequality_sqr_beta2,
                                s_delta = x$social_delta,
                                s_gamma= x$social_gamma,
                                mixed_alpha =x$mixed_alpha,
                                mixed_beta =x$mixed_beta,
                                mixed_gamma =x$mixed_gamma,
                                i_SE_alpha= x$inequality_alpha_se,
                                i_SE_beta= x$inequality_beta_se,
                                ia_sqr_SE_alpha= x$inequality_sqr_alpha_se,
                                ia_sqr_SE_beta= x$inequality_sqr_beta_se,
                                ia_sqr_SE_alpha2= x$inequality_sqr_alpha2_se,
                                #ia_sqr_SE_beta2= x$inequality_sqr_beta2_se,
                                s_SE_delta= x$social_delta_se,
                                s_SE_gamma= x$social_gamma_se,
                                mixed_SE_alpha =x$mixed_alpha_se,
                                mixed_SE_beta =x$mixed_beta_se,
                                mixed_SE_gamma =x$mixed_gamma_se))

models[[length(models)+1]] <- x$models
names_model <- append(names_model, x$treatment)
}

names(models) <- names_model

aic_table <- aic_table %>%
  mutate(Best_model_se_ia=ifelse(Delta_SE_IA_AIC<0,"Social Expectation", "Inequality Aversion"),
         Best_model_ia_iasqr=ifelse(Delta_IA_IASQR_AIC<0,"Inequality Aversion", "Inequality sqr"),
         Best_model_se_iasqr=ifelse(Delta_SE_IASQR_AIC<0,"Social Expectation", "Inequality sqr"),
         Best_model_se_mixed=ifelse(Delta_SE_MIXED_AIC<0,"Social Expectation", "Mixed")) %>%
  left_join(master %>% dplyr::select(treatment_id, Game_type), by = "treatment_id") %>%
  arrange(Game_type)

n_subject <- choices %>%
  group_by(treatment_id) %>%
  summarise(n=length(unique(subject_id)))

social_coeff <- social_coeff %>%
  left_join(master %>% dplyr::select(treatment_id, Game_type), by = "treatment_id") %>%
  left_join(n_subject, by = "treatment_id") %>%
  mutate(i_SE_beta=ifelse(i_SE_beta>100, NA, i_SE_beta),
         ia_sqr_SE_beta=ifelse(ia_sqr_SE_beta>100, NA, ia_sqr_SE_beta),
         #ia_sqr_SE_beta2=ifelse(ia_sqr_SE_beta2>100, NA, ia_sqr_SE_beta2),
         mixed_SE_beta=ifelse(mixed_SE_beta>100, NA, mixed_SE_beta),
         weight_SE=(n)^2) 

average_coeff <- social_coeff %>% summarise(across(i_alpha:mixed_gamma, ~weighted.mean(., w = n, na.rm=T)))
average_SE <- social_coeff %>% summarise(across(i_SE_alpha:mixed_SE_gamma, ~weighted.mean(.^2, w = weight_SE, na.rm=T)))

social_coeff <- social_coeff %>%
   add_row(treatment_id="Average", average_coeff , sqrt(average_SE), Game_type="Average", n=sum(social_coeff$n), weight_SE=sum(social_coeff$weight_SE))
```


```{r bar aic se-ia, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
ggplot(data = aic_table, aes(Delta_SE_IA_AIC, fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_col(aes(fill=Best_model_se_ia)) + 
  xlim(-max(abs(aic_table$Delta_SE_IA_AIC))*1.2,max(abs(aic_table$Delta_SE_IA_AIC))*1.2) +
  xlab("AIC Delta") +
  ylab("Treatment") +
  labs(title = "Social expectation vs Inequality Aversion model")+
  theme_light() +
  theme(legend.position="bottom",
        strip.text.x = element_text(size = 12, color = "black", face = "bold.italic"),
        strip.background = element_blank()) +
  scale_fill_brewer(palette="Set1") +
  facet_wrap(~Game_type) + 
  geom_point(shape=1) +
  geom_vline(xintercept = 0)
```

```{r bar aic ia-iasqr, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
ggplot(data = aic_table, aes(Delta_IA_IASQR_AIC, fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_col(aes(fill=Best_model_ia_iasqr)) + 
  xlim(-max(abs(aic_table$Delta_IA_IASQR_AIC))*1.2,max(abs(aic_table$Delta_IA_IASQR_AIC))*1.2) +
  xlab("AIC Delta") +
  ylab("Treatment") +
  labs(title = "Inequality Aversion model vs Inequality sqr model")+
  theme_light() +
  theme(legend.position="bottom",
        strip.text.x = element_text(size = 12, color = "black", face = "bold.italic"),
        strip.background = element_blank()) +
  scale_fill_brewer(palette="Set1") +
  facet_wrap(~Game_type) + 
  geom_point(shape=1) +
  geom_vline(xintercept = 0)
```

```{r bar aic se-iasqr, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
ggplot(data = aic_table, aes(Delta_SE_IASQR_AIC, fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_col(aes(fill=Best_model_se_iasqr)) + 
  xlim(-max(abs(aic_table$Delta_SE_IASQR_AIC))*1.2,max(abs(aic_table$Delta_SE_IASQR_AIC))*1.2) +
  xlab("AIC Delta") +
  ylab("Treatment") +
  labs(title = "Social expectation vs Inequality sqr model")+
  theme_light() +
  theme(legend.position="bottom",
        strip.text.x = element_text(size = 12, color = "black", face = "bold.italic"),
        strip.background = element_blank()) +
  scale_fill_brewer(palette="Set1") +
  facet_wrap(~Game_type) + 
  geom_point(shape=1) +
  geom_vline(xintercept = 0)
```

```{r bar aic se-mixed, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
ggplot(data = aic_table, aes(Delta_SE_MIXED_AIC, fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_col(aes(fill=Best_model_se_mixed)) + 
  xlim(-max(abs(aic_table$Delta_SE_MIXED_AIC))*1.2,max(abs(aic_table$Delta_SE_MIXED_AIC))*1.2) +
  xlab("AIC Delta") +
  ylab("Treatment") +
  labs(title = "Social expectation vs Mixed model")+
  theme_light() +
  theme(legend.position="bottom",
        strip.text.x = element_text(size = 12, color = "black", face = "bold.italic"),
        strip.background = element_blank()) +
  scale_fill_brewer(palette="Set1") +
  facet_wrap(~Game_type) +
  geom_point(shape=1) +
  geom_vline(xintercept = 0)
```

```{r pointrange se, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# social expectation model
plot_s_delta <- ggplot(social_coeff, aes(x=s_delta,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=s_delta-2*s_SE_delta,xmax=s_delta+2*s_SE_delta, color=Game_type), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of payoff (delta)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_s_gamma <- ggplot(social_coeff, aes(x=s_gamma,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=s_gamma-2*s_SE_gamma,xmax=s_gamma+2*s_SE_gamma, color=Game_type), shape=20) +
  xlab("Coefficient of norm expectation (gamma)") +
  theme_light() +
  theme(axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)
  
ggarrange(plot_s_delta, plot_s_gamma, ncol = 2, common.legend=T, legend="bottom", widths = c(8,6))
```

```{r pointrange ia, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# inequality aversion model
plot_i_alpha <- ggplot(social_coeff, aes(x=i_alpha,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=i_alpha-2*i_SE_alpha,xmax=i_alpha+2*i_SE_alpha, color=Game_type), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of other payoff ahead (alpha)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_i_beta <- ggplot(social_coeff, aes(x=i_beta,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=i_beta-2*i_SE_beta,xmax=i_beta+2*i_SE_beta, color=Game_type), shape=20) +
  xlab("Coefficient of other payoff behind (beta)") +
  theme_light() +
  theme(axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)
  
ggarrange(plot_i_alpha, plot_i_beta, ncol = 2, common.legend=T, legend="bottom", widths = c(8,6))
```

```{r pointrange iasqr, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment="", fig.height=5}
# inequality aversion sqr model
plot_ia_sqr_alpha <- ggplot(social_coeff, aes(x=ia_sqr_alpha,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=ia_sqr_alpha-2*ia_sqr_SE_alpha,xmax=ia_sqr_alpha+2*ia_sqr_SE_alpha, color=Game_type), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of other payoff ahead (alpha)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_ia_sqr_beta <- ggplot(social_coeff, aes(x=ia_sqr_beta,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=ia_sqr_beta-2*ia_sqr_SE_beta,xmax=ia_sqr_beta+2*ia_sqr_SE_beta, color=Game_type), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of other payoff behind (beta)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_ia_sqr_alpha2 <- ggplot(social_coeff, aes(x=ia_sqr_alpha2,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=ia_sqr_alpha2-2*ia_sqr_SE_alpha2,xmax=ia_sqr_alpha2+2*ia_sqr_SE_alpha2, color=Game_type), shape=20) +
  xlab("Coefficient of other payoff behind (alpha2)") +
  theme_light() +
  theme(axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

# plot_ia_sqr_beta2 <- ggplot(social_coeff, aes(x=ia_sqr_beta2,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
#   geom_pointrange(aes(xmin=ia_sqr_beta2-2*ia_sqr_SE_beta2,xmax=ia_sqr_beta2+2*ia_sqr_SE_beta2, color=Game_type), shape=20) +
#   xlab("Coefficient of other payoff behind (beta2)") +
#   theme_light() +
#   theme(axis.text.y=element_blank(),
#         axis.title.y=element_blank(),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank()) +
#   geom_vline(xintercept = 0)
  
ggarrange(plot_ia_sqr_alpha, plot_ia_sqr_alpha2, plot_ia_sqr_beta, ncol = 2, nrow = 2, common.legend=T, legend="bottom", widths = c(8,6))
```

```{r pointrange mixed, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}

# mixed model
plot_mixed_alpha <- ggplot(social_coeff, aes(x=mixed_alpha,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=mixed_alpha-2*mixed_SE_alpha,xmax=mixed_alpha+2*mixed_SE_alpha, color=Game_type), shape=20) +
  ylab("Treatment ID") +
  xlab("Ahead (alpha)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_mixed_beta <- ggplot(social_coeff, aes(x=mixed_beta,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=mixed_beta-2*mixed_SE_beta,xmax=mixed_beta+2*mixed_SE_beta, color=Game_type), shape=20) +
  xlab("Behind (beta)") +
  theme_light() +
  theme(axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_mixed_gamma <- ggplot(social_coeff, aes(x=mixed_gamma,y=fct_rev(fct_reorder(treatment_id, Game_type)))) + 
  geom_pointrange(aes(xmin=mixed_gamma-2*mixed_SE_gamma,xmax=mixed_gamma+2*mixed_SE_gamma, color=Game_type), shape=20) +
  xlab("Norm expectation (gamma)") +
  theme_light() +
  ylab("Treatment ID") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)
  
ggarrange(plot_mixed_alpha, plot_mixed_beta, plot_mixed_gamma, ncol = 2, nrow=2,common.legend=T, legend="bottom", widths = c(8,6))
```

```{r real and predict, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
list_treatment=unique(master_aic_analysis$treatment_id)

scenarios_treatment <- choices_aic_analysis %>%
  group_by(treatment_id) %>%
  summarise(n_scen=length(unique(scenarios)),
            first_scen = min(scenarios),
            last_scen = max(scenarios),
            step_scen = round((last_scen-first_scen+1)/n_scen, digits = 1))

df_real <- choices_aic_analysis %>%
  filter(A==1) %>%
  group_by(treatment_id, choice) %>%
  summarise(n_sub=n()) %>%
  group_by(treatment_id) %>%
  mutate(tot_sub=sum(n_sub),
         percentage=round(n_sub/tot_sub*100, digits = 2)) %>%
  left_join(scenarios_treatment, by = "treatment_id")

n=1
list_plot <- c()

for (i in list_treatment) {
  
  # dataset
  temp_choice <- df_real %>% 
    filter(treatment_id == i) %>%
    mutate(model="real")
  temp_model <- models[[i]]
  temp_predict_se <- data.frame(choice=seq(as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"first_scen"]), 
                                              as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"last_scen"]), 
                                              as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"step_scen"])),
                                percentage=predict(temp_model[[1]], type = "expected")[1:as.integer(scenarios_treatment[scenarios_treatment$treatment_id==i,"n_scen"])]*100) %>%
    mutate(model="social",
           treatment_id=i)
  
  temp_predict_ia <- data.frame(choice=seq(as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"first_scen"]), 
                                              as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"last_scen"]), 
                                              as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"step_scen"])),
                                percentage=predict(temp_model[[2]], type = "expected")[1:as.integer(scenarios_treatment[scenarios_treatment$treatment_id==i,"n_scen"])]*100)%>%
    mutate(model="inequality",
           treatment_id=i)
  
  temp_predict_sqr <- data.frame(choice=seq(as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"first_scen"]), 
                                              as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"last_scen"]), 
                                              as.numeric(scenarios_treatment[scenarios_treatment$treatment_id==i,"step_scen"])),
                                percentage=predict(temp_model[[3]], type = "expected")[1:as.integer(scenarios_treatment[scenarios_treatment$treatment_id==i,"n_scen"])]*100)%>%
    mutate(model="sqr",
           treatment_id=i)
  

  
  
  # list
  p <- ggplot(rbind.data.frame(temp_choice %>% dplyr::select(treatment_id,choice, percentage, model), temp_predict_se, temp_predict_ia, temp_predict_sqr), 
             aes(x=choice, 
                 y=percentage, fill=model)) + 
            geom_bar(stat="identity", position = "dodge") + 
      labs(title = i) +
      xlab("Choice") + 
      ylab("Subjects (%)")
  # 
  list_plot[[n]] <- p
  n=n+1
}

do.call('grid.arrange',c(list_plot, ncol = 3, nrow = 3, common.legend=T, legend="bottom"))
```

## Bicchieri Analysis
```{r bicchieri analysis, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
# BICCHIERI ANALYSIS

pgg_t <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/1IoJDOQWCFiL1qTzSja6byrAlCelNSTsT/Meta-analysis beliefs/Dati paper/2021Sze167/full.csv") %>% 
  dplyr::select(treatment, id, round, excluded, contribution, contribute_cond, pnb, ee1:ee5, ee_avg, ne1:ne5, ne_avg) %>%
  filter(#round==1 &
           !(is.na(contribution)) & 
           excluded!="Excluded" &
           !(is.na(ee1))) %>%
  mutate(coop = contribution/100,
         inf_ne = ne_avg - contribution,
         inf_ee = ee_avg - contribution,
         sub_treat = ifelse(round>14,1,0))

ml.all <- lmer(contribution ~ 0 + ne_avg + ee_avg + pnb + (1|treatment) + (1 + ne_avg + ee_avg + pnb|round), pgg_t)

pgg_t_rep <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/1IoJDOQWCFiL1qTzSja6byrAlCelNSTsT/Meta-analysis beliefs/Dati paper/2021Sze167/full_replicated.csv") %>%
  dplyr::select(treatment, id, round, excluded, contribution, contribute_cond, pnb, ee1:ee5, ee_avg, ne1:ne5, ne_avg) %>%
  filter(#round==1&
           !(is.na(contribution)) & 
           excluded!="Excluded" &
           !(is.na(ee1))) %>%
  mutate(coop = contribution/100,
         inf_ne = ne_avg - contribution,
         inf_ee = ee_avg - contribution,
         sub_treat = ifelse(round>14,1,0))

ml.all_rep <- lmer(contribution ~ 0 + ne_avg + ee_avg + pnb + (1|treatment) + (1 + ne_avg + ee_avg + pnb|round), pgg_t_rep)

tab_model(ml.all, ml.all_rep, dv.labels = c("First", "Replicated"), show.aic = T, show.loglik = T, show.se = T, show.ci = F, title = "First and Replicated verison - all round, effect: treatment and round", transform=NULL)


```

## MODEL BY STATA
```{r stata_output_model_DG, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
getwd()
stata_output_model_DG <- read_excel("stata output model DG.xlsx")

stata_output_model_DG <- stata_output_model_DG %>%
  mutate(weight_SE=(n_obs)^2) 

average_coeff_stata <- stata_output_model_DG %>% summarise(across(s_delta:cr_sigma, ~weighted.mean(., w = n_obs, na.rm=T)))
average_SE_stata <- stata_output_model_DG %>% summarise(across(s_delta_SE:cr_sigma_SE, ~weighted.mean(.^2, w = weight_SE, na.rm=T)))

stata_output_model_DG <- stata_output_model_DG %>%
   add_row(treatment_id="Average", average_coeff_stata , sqrt(average_SE_stata), n_obs=sum(stata_output_model_DG$n_obs), weight_SE=sum(stata_output_model_DG$weight_SE))
```

```{r pointrange model by stata, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
# graphic

## social expectation model
plot_s_delta <- ggplot(stata_output_model_DG, aes(x=s_delta,y=treatment_id)) + 
  geom_pointrange(aes(xmin=s_delta-1.96*s_delta_SE,xmax=s_delta+1.96*s_delta_SE), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of payoff (delta)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_s_gamma <- ggplot(stata_output_model_DG, aes(x=s_gamma,y=treatment_id)) + 
  geom_pointrange(aes(xmin=s_gamma-1.96*s_gamma_SE,xmax=s_gamma+1.96*s_gamma_SE), shape=20) +
  xlab("Coefficient of norm expectation (gamma)") +
  theme_light() +
  theme(axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)
  
ggarrange(plot_s_delta, plot_s_gamma, ncol = 2, common.legend=T, legend="bottom", widths = c(8,6))

# inequality aversion model
plot_cr_rho <- ggplot(stata_output_model_DG, aes(x=cr_rho,y=treatment_id)) + 
  geom_pointrange(aes(xmin=cr_rho-1.96*cr_rho_SE,xmax=cr_rho+1.96*cr_rho_SE), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of other payoff ahead (rho)") +
  theme_light() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)

plot_cr_sigma <- ggplot(stata_output_model_DG, aes(x=cr_sigma,y=treatment_id)) + 
  geom_pointrange(aes(xmin=cr_sigma-1.96*cr_sigma_SE,xmax=cr_sigma+1.96*cr_sigma_SE), shape=20) +
  ylab("Treatment ID") +
  xlab("Coefficient of other payoff behind (sigma)") +
  theme_light() +
  theme(axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  geom_vline(xintercept = 0)
  
ggarrange(plot_cr_rho, plot_cr_sigma, ncol = 2, common.legend=T, legend="bottom", widths = c(8,6))
```

```{r aic comparison stata, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, comment=""}
stata_aic <- read_excel("stata aic DG.xlsx") %>%
  mutate(Best_model_se_cr=ifelse(Delta_se_cr<0,"Social Expectation", "Charness & Rubin"))

ggplot(data = stata_aic, aes(Delta_se_cr, treatment_id)) + 
  geom_col(aes(fill=Best_model_se_cr)) + 
  xlim(-max(abs(stata_aic$Delta_se_cr))*1.2,max(abs(stata_aic$Delta_se_cr))*1.2) +
  xlab("AIC Delta") +
  ylab("Treatment") +
  labs(title = "Social expectation vs Charness & Rubin")+
  theme_light() +
  theme(legend.position="bottom",
        strip.text.x = element_text(size = 12, color = "black", face = "bold.italic"),
        strip.background = element_blank()) +
  scale_fill_brewer(palette="Set1") + 
  geom_point(shape=1) +
  geom_vline(xintercept = 0)
```

